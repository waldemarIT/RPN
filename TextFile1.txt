20
MIN ( 3 + 5 , IF ( 2 , 7 , 11 ) , ( 15 / 3 ) , 1 + 4 , ( 17 * 16 ) ) + ( MAX ( 10 , 1 , 2 ) * IF ( 14 , 9 , 17 ) ) . 
MIN ( MIN ( MAX ( 0 ) , IF ( 7 , 17 , 11 ) , IF ( 6 , 8 , 17 ) ) , IF ( MAX ( 12 , 14 , 12 , 18 ) , N ( 5 ) , IF ( 13 , 7 , 18 ) ) ) . 
IF ( IF ( 15 / 8 , ( 13 - 8 ) , MIN ( 7 , 10 , 14 , 6 , 8 ) ) , ( IF ( 2 , 8 , 9 ) + IF ( 11 , 8 , 8 ) ) , IF ( MAX ( 16 , 7 ) , ( 17 * 0 ) , MIN ( 7 , 0 , 6 ) ) ) . 
IF ( N MIN ( 8 , 16 , 17 , 17 , 0 ) , IF ( IF ( 12 , 2 , 9 ) , ( 8 * 0 ) , IF ( 2 , 7 , 6 ) ) , IF ( MAX ( 12 , 10 , 8 , 14 ) , MAX ( 15 , 11 ) , MIN ( 8 ) ) ) . 
N MIN ( IF ( 6 , 7 , 3 ) ) . 
0 * 4 / ( 12 * 13 ) - IF ( 4 / 14 , MIN ( 4 , 4 , 3 , 0 ) , 1 * 19 ) . 
MAX ( MAX ( ( 10 + 5 ) , ( 3 * 8 ) , IF ( 12 , 12 , 9 ) , MAX ( 13 , 1 , 13 , 10 ) ) , IF ( 3 - 17 , 14 + 1 , ( 3 * 11 ) ) , IF ( IF ( 18 , 18 , 14 ) , IF ( 1 , 4 , 17 ) , N 12 ) ) . 
MIN ( IF ( MIN ( 15 , 9 , 0 , 8 , 12 , 13 ) , IF ( 0 , 3 , 16 ) , ( 12 + 8 ) ) ) . 
IF ( MIN ( MIN ( 19 , 12 ) , MIN ( 3 , 16 , 14 , 19 ) , MAX ( 5 ) , 15 + 11 , IF ( 16 , 5 , 8 ) ) , IF ( IF ( 19 , 0 , 2 ) , ( 16 + 16 ) , IF ( 16 , 2 , 12 ) ) , IF ( IF ( 12 , 19 , 19 ) , IF ( 13 , 15 , 17 ) , IF ( 6 , 10 , 4 ) ) ) . 
MAX ( ( IF ( 0 , 9 , 6 ) + ( 6 * 1 ) ) , IF ( ( 9 + 9 ) , IF ( 10 , 16 , 8 ) , MIN ( 4 , 16 ) ) , MAX ( MAX ( 3 , 18 , 4 ) ) , IF ( IF ( 3 , 15 , 17 ) , IF ( 18 , 5 , 14 ) , 5 * 14 ) , MIN ( ( 10 - 11 ) , IF ( 2 , 15 , 18 ) , ( 16 * 11 ) ) ) . 
IF ( IF ( IF ( 8 , 5 , 18 ) , IF ( 6 , 5 , 5 ) , 17 / 2 ) , IF ( IF ( 2 , 4 , 19 ) , MAX ( 14 , 9 , 2 , 6 , 1 , 17 ) , IF ( 2 , 6 , 10 ) ) , IF ( 4 + 17 , MIN ( 8 ) , ( 2 / 11 ) ) ) . 
IF ( IF ( IF ( 15 , 11 , 3 ) , 19 * 11 , MIN ( 0 , 10 ) ) , MIN ( ( 11 * 2 ) ) , IF ( MIN ( 18 , 0 , 13 , 14 , 9 ) , MIN ( 1 , 8 , 10 ) , 11 * 0 ) ) . 
MIN ( MAX ( IF ( 1 , 1 , 5 ) , IF ( 5 , 10 , 17 ) , MAX ( 15 , 12 , 9 ) , MIN ( 3 , 3 , 11 ) ) ) . 
MIN ( MIN ( IF ( 9 , 14 , 15 ) , 16 + 16 , IF ( 12 , 6 , 18 ) , MAX ( 12 , 14 , 4 , 3 ) , MIN ( 12 , 7 , 17 , 9 , 4 ) ) , IF ( N ( 9 ) , IF ( 12 , 15 , 3 ) , N ( 1 ) ) ) . 
IF ( IF ( IF ( 17 , 13 , 13 ) , 2 + 11 , IF ( 19 , 16 , 8 ) ) , ( ( 19 / 13 ) + ( 19 / 12 ) ) , MAX ( 0 , 12 ) / ( 18 + 0 ) ) . 
( IF ( 0 * 4 , N 1 , MAX ( 14 , 4 , 6 ) ) - IF ( MAX ( 13 , 15 , 1 , 9 , 18 , 9 ) , MIN ( 1 , 8 , 2 , 7 , 18 ) , ( 10 * 11 ) ) ) . 
MAX ( IF ( 9 - 14 , N 12 , MAX ( 12 ) ) , MAX ( 10 , 2 , 15 , 19 , 10 ) - MAX ( 16 , 12 ) , ( 14 / 11 ) - ( 6 / 7 ) , MIN ( IF ( 15 , 9 , 13 ) , IF ( 3 , 1 , 1 ) , IF ( 2 , 2 , 1 ) , MAX ( 18 ) , IF ( 13 , 6 , 8 ) ) ) . 
IF ( MIN ( IF ( 3 , 9 , 18 ) , IF ( 12 , 10 , 3 ) , ( 11 * 18 ) , MAX ( 16 , 0 , 9 , 9 , 1 ) ) , IF ( 9 , 6 , 7 ) - IF ( 15 , 3 , 11 ) , MIN ( IF ( 9 , 15 , 8 ) , ( 8 / 19 ) , ( 10 + 6 ) , MIN ( 19 ) , MIN ( 7 , 14 , 8 ) , MAX ( 16 , 17 , 15 , 4 , 11 , 2 ) ) ) . 
IF ( 12 + 7 , MIN ( 17 , 17 ) , IF ( 6 , 11 , 1 ) ) * IF ( 0 + 10 , N ( 17 ) , IF ( 19 , 15 , 7 ) ) . 
N IF ( 19 , 16 , 0 ) / IF ( 12 , MAX ( 0 , 1 , 4 ) , 6 ) . 


1
MIN ( 3 + 4 , IF ( 1 , 5 , 7 ) , 2 ) .





/*if (strncmp(c, "MIN", 3) == 0 ||
                    (strncmp(c, "MAX", 3) == 0)) {

                    char buffer[100];
                    int number_of_elements = countElements(tokens, i);
                    sprintf(buffer, "%ld", number_of_elements);
                    char* op = new char[20];
                    strncpy(op, c, 3);
                    int indx_elements;
                    for (indx_elements = 0; buffer[indx_elements] != '\0'; indx_elements++) {
                        op[indx_elements + 3] = buffer[indx_elements];
                    }
                    op[indx_elements + 3] = '\0';

                    if (token.isOperator(stack.top())) {
                        result.push_back(stack.top());
                    }

                    stack.push_back(op);

                }*/

/* else  if (strncmp(c, "MIN", 3) == 0 && strncmp(stack.top(), "N", 1) == 0) { break; }
                else  if (strncmp(c, "IF", 2) == 0 && strncmp(stack.top(), "IF", 2) == 0) { break; }
                else  if (strncmp(c, "MAX", 3) == 0 && strncmp(stack.top(), "IF", 2) == 0) { break; }
                else  if (strncmp(c, "N", 1) == 0 && strncmp(stack.top(), "IF", 2) == 0) { break; }*/

const int MIN = -1;
const int OPEN = -2;
const int CLOSE = -3;
const int COMMA = -4;

int Parser::countElements(char** expr, int pos) {
    LinkedList<int> s; // Stos do ?ledzenia otwarcia i zamkni?cia nawiasów oraz przecinków.
    int args = 0; // Liczba argumentów w najbardziej zewn?trznej funkcji.

    int depth = 0; // G??boko?? zagnie?d?enia nawiasów.

    for (int i = pos; expr[i] != nullptr && strcmp(expr[i], ".") != 0; ++i) {
        if (strcmp(expr[i], "(") == 0) {
            s.push_back(-2); // Symbolizuje otwarcie nawiasu.
            depth++;
            if (depth == 1) { // Resetujemy liczb? argumentów tylko dla pierwszego poziomu.
                args = 1; // Resetujemy, zak?adaj?c, ?e zawsze jest co najmniej jeden argument.
            }
        }
        else if (strcmp(expr[i], ")") == 0) {
            s.pop_back(); // Usuwamy otwarcie nawiasu.
            depth--;
            if (s.isEmpty()) {
                // Je?li stos jest pusty, zako?czyli?my analiz? najbardziej zewn?trznej funkcji.
                return args;
            }
        }
        else if (strcmp(expr[i], ",") == 0 && depth == 1) {
            args++; // Ka?dy przecinek na pierwszym poziomie zagnie?d?enia oznacza kolejny argument.
        }
    }

    return -1;
}

 case 'M':
                if (strncmp(token, "MIN", 3) == 0) {
                    
                    if (stack.size() < 1) {
                        cerr << "ERROR: Not enough values in the stack for MIN operation." << endl;
                        success = false;
                        return -1;
                    }

                    int count_elem = strtol(token + 3, nullptr, 10);

                    cout << token << " "; stack.show_reverse();
                    int len = stack.size();
                    int min_val;

                    if (count_elem <= 0) {
                        cerr << "ERROR: Invalid number of elements for MIN operation." << endl;
                        success = false;
                        return -1;
                    }
                    else if (count_elem == 1) {
                        result = stack[len - 1]; 
                    }
                    else {
                        min_val = stack[len - 1];
                        for (int j = len - 1; j >= len - count_elem; j--) {
                            if (stack[j] < min_val) {
                                min_val = stack[j];
                            }
                        }
                        for (int j = len - 1; j >= len - count_elem; j--) {
                            stack.pop_back();
                        }
                        result = min_val;
                    }

                    
                }
                else if (strncmp(token, "MAX", 3) == 0) {
                    if (stack.size() < 1) {
                        cerr << "ERROR: Not enough values in the stack for MAX operation." << endl;
                        success = false;
                        return -1;
                    }
                    int count_elem = strtol(token + 3, nullptr, 10);

                    cout << token << " "; stack.show_reverse();
                    int len = stack.size();
                    int max_val;
                    if (count_elem <= 0) {
                        cerr << "ERROR: Not enough values in the stack for MAX operation." << endl;
                        success = false;
                        return -1;
                    }
                    else if (count_elem == 1) {
                        result = stack[len - 1];
                    }
                    else {
                        max_val = stack[len - 1];
                        for (int j = len - 1; j >= len - count_elem; j--) {
                            if (stack[j] > max_val) {
                                max_val = stack[j];
                            }
                        }
                        for (int j = len - 1; j >= len - count_elem; j--) {
                            stack.pop_back();
                        }
                        result = max_val;
                    }
                }
                break;


  if (strncmp(c, "MIN", 3) == 0  ||
                    (strncmp(c, "MAX", 3) == 0 ) ) {
                    //cout << "cocokc " << endl;
                    char buffer[100];
                    int number_of_elements = countElements(tokens, i);
                    sprintf(buffer, "%ld", number_of_elements);
                    char* op = new char[20];
                    strncpy(op, c, 3);
                    int indx_elements;
                    for (indx_elements = 0; buffer[indx_elements] != '\0'; indx_elements++) {
                        op[indx_elements + 3] = buffer[indx_elements];
                    }
                    op[indx_elements + 3] = '\0';

                    if (token.isOperator(stack.top())) {
                        result.push_back(stack.top());
                    }
                  
                    stack.push_back(op);

                }


                /*if (stack.size() < 1) {
                        cerr << "ERROR: Not enough values in the stack for MIN operation." << endl;
                        success = false;
                        return -1;
                    }
                    int count_elem = strtol(token + 3, nullptr, 10);

                    cout << token << " "; stack.show_reverse();
                    int len = stack.size();
                    min_val = stack[len - 1]; 
                    for (int j = len - 1; j >= len - count_elem; j--) {
                        if (stack[j] < min_val) {
                            min_val = stack[j];
                        }
                    }
                    for (int j = len - 1; j >= len - count_elem; j--) {
                        stack.pop_back();
                    }
                    result = min_val;*/